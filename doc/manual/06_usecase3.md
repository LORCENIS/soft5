# Use Case 3. Coupling of parScale to Ansys FLUENT

This use case demonstrates that effectiveness factors and effective reaction parameters calculated by the particle scale model **parScale** can be used in **Ansys FLUENT** by generating a UDF using **Porto**. 

## Walkthrough

This walkthrough is a continuation from the previous Use Case and assumes that it has already been run, followed by running parScale. ParScale will in this case have produced the following output:

* An `effectivenessFactor.json` file containing a description of the functional form of the effectiveness factor.
* An `effectiveReactionparameters.json` file containing a description of the functional form of the effective reaction parameters.

By "functional form" we here mean that each of these properties are described by the choice of a function and arguments to this function. For example, one simple functional form with one argument could be a _constant effectiveness factor_, written in C code as

```c
double constantEffectivenessFactor(double c) {
  return c;
}
```

To simplify this use case, we are considering only the case of the constant effectiveness factor.

Since the choice of functional form that best represents the different parameters (effectiveness factor and effective reaction parameters) are expressed by parScale, we can use this information to generate an Ansys FLUENT UDF which takes this into account. Generation of the UDF is similar to the UDF generation done in Use Case 1.

In order to store the output from ParScale to Porto, we run the following tool:

```bash
$ cd ~/build/soft5/porto/src/parscale-effectiveness-factor
$ ./parscale-effectiveness-factor ~/source/soft5/porto/examples/parscale/effectivenessFactor_example.json  ~/source/soft5/porto/examples/parscale/effectiveReactionparameters_example.json a6a71841-139a-4310-a9e6-ef7a6f161a6f
```

This will read the effectiveness factors and effective reaction parameters and store them in Porto under the collection referred to by the uuid. Note that the uuid used here is the same as in Use Case 2.

Following this, the UDFs can be generated by running

```bash
./generate-effectiveness-udf.js a6a71841-139a-4310-a9e6-ef7a6f161a6f > udf.c
```

which will generate the C code defining the UDF. This can then be compiled and used with Ansys FLUENT.


## Details

### `effectivenessFactor.json`

The `.json` file generated by parScale has the following example structure:

```json
{
  "name": "effectivenessFactor",
  "nparameters": 1,
  "functionalForm": "constant",
  "parameters": [
    0.1234
  ],
  "argumentCount": 0
}
```

### `effectiveReactionparameters.json`

The `.json` file generated by parScale has the following example structure:

```json
{
  "name": "effectiveReactionparameters",
  "nparameters": 2,
  "multiplyByParticleVolumeFraction": true,
  "functionalForm": "OneMinusConversionTimesConcentration",
  "parameters": [
    0.6667,
    1
  ],
  "argumentCount": 3
}
```

### `generate-effectiveness-udf.js`

The script used to generate the UDFs.

```js
#!/usr/bin/env softshell
var entity = require('porto.entity');
porto.EffectivenessFactor = entity.using('effectivenessfactor', 'eu.nanosim.parscale', '0.2');
porto.EffectiveReactionparameters = entity.using('effectivereactionparameters', 'eu.nanosim.parscale', '0.2');
porto.ChemkinReaction = entity.using('chemkinReaction', 'eu.nanosim.vasp', '0.1');

__main__ = function (args) {
    try {
        // Check that the user provides sufficient arguments to the program
        if (args.length < 2) {
            print("Usage " + args[0] + " <uuid>");
            return;
        }

        var uuid = args[1];

        // Attempt to talk to the local mongodb
        var storage = new porto.Storage("mongo2", "mongodb://localhost", "db=porto;coll=demo");

        // Load the collection given by the uuid on the command line, then retrieve all
        // reaction entities in this collection
        collection = new porto.Collection(uuid);
        storage.load(collection);

        var effectivenessfactorID = collection.findRelations("Effectivenessfactor", "id");
        var effectivereactionparametersID = collection.findRelations("Effectivereactionparameters", "id");

        var reactionDataIds = collection.findRelations("reactiondata", "has-id");

        var ef = new porto.EffectivenessFactor(effectivenessfactorID);
        ef.read(storage);

        if (ef.arguments.length != 0 || ef.parameters.length != 1 || ef.functionalForm != "constant") {
            throw "I do not understand any other functional forms for the effectiveness factor than the constant form.";
        }

        var erp = new porto.EffectiveReactionparameters(effectivereactionparametersID);
        erp.read(storage);
        
        reactionDataIds.forEach(function (reactionId) {
            var reaction = new porto.ChemkinReaction(reactionId);
            reaction.read(storage);

            console.raw("/* ---[ GENERATED UDF ]------------------------------------------------------ */\n");
            console.raw("/* Collection uuid: " + collection.id() + " */ \n");
            console.raw("/* effectivenessfactorID: " + effectivenessfactorID + " */\n");
            console.raw("/* effectivereactionparametersID: " + effectivereactionparametersID + " */\n");
            console.raw("/* ChemkinReactionID: " + reactionId + "*/\n");

            // Pass the aggregated information from the entity to the code generator (soft.mvc). The
            // variables here (elements, species, reactions) can be found in the template specified
            // below. This will substitute the template entrires such as @{elements} with the contents
            // specified below.
            var controller = require('soft.mvc').create({
                model: {
                    k0: reaction.A / 10e6,
                    EA: reaction.Ea * 10e3,
                    eff: ef.parameters[0]
                },
                view: "./template/effectiveness-udf.cjs"
            });

            // Output the generated code directly to the console.
            console.raw(controller());
        }); 

    } catch (err) {
        // Any error caught during execution is logged to the console.
        console.raw("ERROR: Failed generating code.\nReason: " + err + "\n");
    }

};
```

### `udf.cjs`

The template used to generate the UDFs.

```c
#include "udf.h"

real min_cutoff = 1e-6;          /* Stops the reaction when reactants approach zero to ensure stability */
real Gas_Const = 8.314;          /* Ideal gas constant [J/mol/K] */
real k0 = @{soft.model.k0};      /* Pre-exponential factor [m3/mol/s] from Chemkin files. Chemkin file value [cm3/mol/s] must be divided by 10^6. */
real EA = @{soft.model.EA};      /* Activation energy [J/mol] from Chemkin files. Chemkin file value [kJ/mol] must be multiplied by 10^3. */

DEFINE_HET_RXN_RATE(Rrate,c,t,r,mw,yi,rr,rr_t)
{
   real Rrate, k, X_CH4, MW_CH4, X_Fe2O3, MW_Fe2O3, VOF, T, rho_g, rho_s, eff;
   Thread *tg = THREAD_SUB_THREAD(t,0);
   Thread *ts = THREAD_SUB_THREAD(t,1);

   VOF = C_VOF(c,ts);            /* Particle volume fraction [-]*/
   T = C_T(c,ts);                /* Particle temperature [K]*/
   rho_g = C_R(c,tg);            /* Gas density [kg/m3] */
   rho_s = C_R(c,ts);            /* Particle density [kg/m3] */
   X_CH4 = yi[0][0];             /* Methane mass fraction (check second index if order of species in gas is altered) */
   MW_CH4 = mw[0][0]/1000.;      /* Methane molar weight [kg/mol] (check second index if order of species in gas is altered) */
   X_Fe2O3 = yi[1][1];           /* Hematite mass fraction (check second index if order of species in gas is altered) */
   MW_Fe2O3 = mw[1][1]/1000.;    /* Hematite molar weight [kg/mol] (check second index if order of species in gas is altered) */

   k = k0 * exp(-EA/(Gas_Const*T)); /* Reaction rate constant calculated from Chemkin file inputs [m3/mol/s] */

   eff = @{soft.model.eff};      /* Effectiveness factor from Parscale. Should probably be expressed as a function of the Thiele modulus and the particle conversion. */

   Rrate = eff * VOF * k * (rho_g*X_CH4/MW_CH4) * (rho_s*X_Fe2O3/MW_Fe2O3/6.);  /* Reaction rate [mol/m3/s]. Fe2O3 molar concentration is divided by 6 to represent Fe12O18. */

   if (X_CH4 < min_cutoff) Rrate = 0;

   if (X_Fe2O3 < min_cutoff) Rrate = 0; 

   if (VOF < min_cutoff) Rrate = 0;

   *rr = Rrate / 1000.0;         /* Return final reaction rate to FLUENT [kmol/m3/s] */
}
```

